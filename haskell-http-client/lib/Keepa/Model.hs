{-
   Keepa API

   The Keepa API offers numerous endpoints.  Every request requires your API access key as a parameter. You can find and change your key in the keepa portal. All requests must be issued as a HTTPS GET and accept gzip encoding. If possible, use a Keep-Alive connection.  Multiple requests can be made in parallel to increase throughput.

   OpenAPI Version: 3.0.1
   Keepa API API version: 1.0.0
   Contact: info@keepa.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Keepa.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Keepa.Model where

import Keepa.Core
import Keepa.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Asin
newtype Asin = Asin { unAsin :: Text } deriving (P.Eq, P.Show)

-- ** Category2
newtype Category2 = Category2 { unCategory2 :: Int } deriving (P.Eq, P.Show)

-- ** Code
newtype Code = Code { unCode :: Text } deriving (P.Eq, P.Show)

-- ** Domain
newtype Domain = Domain { unDomain :: E'DomainId } deriving (P.Eq, P.Show)

-- ** Key
newtype Key = Key { unKey :: Text } deriving (P.Eq, P.Show)

-- ** Parents
newtype Parents = Parents { unParents :: E'Parents } deriving (P.Eq, P.Show)

-- * Models


-- ** Category
-- | Category
data Category = Category
  { categoryDomainId :: !(E'DomainId) -- ^ /Required/ "domainId" - Integer value for the Amazon locale you want to access. (1-com, 2-co.uk, 3-de, 4-fr, 5-co.jp, 6-ca, 7-cn, 8-it, 9-es, 10-in, 11-com.mx, 12-com.br, 13-com.au)
  , categoryCatId :: !(Int) -- ^ /Required/ "catId" - The category node id used by Amazon. Represents the identifier of the category. Also part of the Product object’s categories and rootCategory fields. Always a positive Long value. Note - The id 9223372036854775807 (max signed long value) denotes a blank category with the name “?”. We use this in cases where a product is listed in no or non-existent categories.
  , categoryName :: !(Text) -- ^ /Required/ "name" - The name of the category.
  , categoryChildren :: !([Int]) -- ^ /Required/ "children" - List of all sub categories. null or [] (empty array) if the category has no sub categories.
  , categoryParent :: !(Int) -- ^ /Required/ "parent" - The parent category’s Id. Always a positive Long value. If it is 0 the category is a root category and has no parent category.
  , categoryHighestRank :: !(Int) -- ^ /Required/ "highestRank" - The highest (root category) sales rank we have observed of a product that is listed in this category. Note- Estimate, as the value is from the Keepa product database and not retrieved from Amazon.
  , categoryProductCount :: !(Int) -- ^ /Required/ "productCount" - Number of products that are listed in this category. Note- Estimate, as the value is from the Keepa product database and not retrieved from Amazon.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Category
instance A.FromJSON Category where
  parseJSON = A.withObject "Category" $ \o ->
    Category
      <$> (o .:  "domainId")
      <*> (o .:  "catId")
      <*> (o .:  "name")
      <*> (o .:  "children")
      <*> (o .:  "parent")
      <*> (o .:  "highestRank")
      <*> (o .:  "productCount")

-- | ToJSON Category
instance A.ToJSON Category where
  toJSON Category {..} =
   _omitNulls
      [ "domainId" .= categoryDomainId
      , "catId" .= categoryCatId
      , "name" .= categoryName
      , "children" .= categoryChildren
      , "parent" .= categoryParent
      , "highestRank" .= categoryHighestRank
      , "productCount" .= categoryProductCount
      ]


-- | Construct a value of type 'Category' (by applying it's required fields, if any)
mkCategory
  :: E'DomainId -- ^ 'categoryDomainId': Integer value for the Amazon locale you want to access. (1-com, 2-co.uk, 3-de, 4-fr, 5-co.jp, 6-ca, 7-cn, 8-it, 9-es, 10-in, 11-com.mx, 12-com.br, 13-com.au)
  -> Int -- ^ 'categoryCatId': The category node id used by Amazon. Represents the identifier of the category. Also part of the Product object’s categories and rootCategory fields. Always a positive Long value. Note - The id 9223372036854775807 (max signed long value) denotes a blank category with the name “?”. We use this in cases where a product is listed in no or non-existent categories.
  -> Text -- ^ 'categoryName': The name of the category.
  -> [Int] -- ^ 'categoryChildren': List of all sub categories. null or [] (empty array) if the category has no sub categories.
  -> Int -- ^ 'categoryParent': The parent category’s Id. Always a positive Long value. If it is 0 the category is a root category and has no parent category.
  -> Int -- ^ 'categoryHighestRank': The highest (root category) sales rank we have observed of a product that is listed in this category. Note- Estimate, as the value is from the Keepa product database and not retrieved from Amazon.
  -> Int -- ^ 'categoryProductCount': Number of products that are listed in this category. Note- Estimate, as the value is from the Keepa product database and not retrieved from Amazon.
  -> Category
mkCategory categoryDomainId categoryCatId categoryName categoryChildren categoryParent categoryHighestRank categoryProductCount =
  Category
  { categoryDomainId
  , categoryCatId
  , categoryName
  , categoryChildren
  , categoryParent
  , categoryHighestRank
  , categoryProductCount
  }


-- * Enums


-- ** E'DomainId

-- | Enum of 'Int' . 
-- Integer value for the Amazon locale you want to access. (1-com, 2-co.uk, 3-de, 4-fr, 5-co.jp, 6-ca, 7-cn, 8-it, 9-es, 10-in, 11-com.mx, 12-com.br, 13-com.au)
data E'DomainId
  = E'DomainId'Num1 -- ^ @1@
  | E'DomainId'Num2 -- ^ @2@
  | E'DomainId'Num3 -- ^ @3@
  | E'DomainId'Num4 -- ^ @4@
  | E'DomainId'Num5 -- ^ @5@
  | E'DomainId'Num6 -- ^ @6@
  | E'DomainId'Num7 -- ^ @7@
  | E'DomainId'Num8 -- ^ @8@
  | E'DomainId'Num9 -- ^ @9@
  | E'DomainId'Num10 -- ^ @10@
  | E'DomainId'Num11 -- ^ @11@
  | E'DomainId'Num12 -- ^ @12@
  | E'DomainId'Num13 -- ^ @13@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'DomainId where toJSON = A.toJSON . fromE'DomainId
instance A.FromJSON E'DomainId where parseJSON o = P.either P.fail (pure . P.id) . toE'DomainId =<< A.parseJSON o
instance WH.ToHttpApiData E'DomainId where toQueryParam = WH.toQueryParam . fromE'DomainId
instance WH.FromHttpApiData E'DomainId where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'DomainId
instance MimeRender MimeMultipartFormData E'DomainId where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'DomainId' enum
fromE'DomainId :: E'DomainId -> Int
fromE'DomainId = \case
  E'DomainId'Num1 -> 1
  E'DomainId'Num2 -> 2
  E'DomainId'Num3 -> 3
  E'DomainId'Num4 -> 4
  E'DomainId'Num5 -> 5
  E'DomainId'Num6 -> 6
  E'DomainId'Num7 -> 7
  E'DomainId'Num8 -> 8
  E'DomainId'Num9 -> 9
  E'DomainId'Num10 -> 10
  E'DomainId'Num11 -> 11
  E'DomainId'Num12 -> 12
  E'DomainId'Num13 -> 13

-- | parse 'E'DomainId' enum
toE'DomainId :: Int -> P.Either String E'DomainId
toE'DomainId = \case
  1 -> P.Right E'DomainId'Num1
  2 -> P.Right E'DomainId'Num2
  3 -> P.Right E'DomainId'Num3
  4 -> P.Right E'DomainId'Num4
  5 -> P.Right E'DomainId'Num5
  6 -> P.Right E'DomainId'Num6
  7 -> P.Right E'DomainId'Num7
  8 -> P.Right E'DomainId'Num8
  9 -> P.Right E'DomainId'Num9
  10 -> P.Right E'DomainId'Num10
  11 -> P.Right E'DomainId'Num11
  12 -> P.Right E'DomainId'Num12
  13 -> P.Right E'DomainId'Num13
  s -> P.Left $ "toE'DomainId: enum parse failure: " P.++ P.show s


-- ** E'Parents

-- | Enum of 'Int'
data E'Parents
  = E'Parents'Num0 -- ^ @0@
  | E'Parents'Num1 -- ^ @1@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Parents where toJSON = A.toJSON . fromE'Parents
instance A.FromJSON E'Parents where parseJSON o = P.either P.fail (pure . P.id) . toE'Parents =<< A.parseJSON o
instance WH.ToHttpApiData E'Parents where toQueryParam = WH.toQueryParam . fromE'Parents
instance WH.FromHttpApiData E'Parents where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Parents
instance MimeRender MimeMultipartFormData E'Parents where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Parents' enum
fromE'Parents :: E'Parents -> Int
fromE'Parents = \case
  E'Parents'Num0 -> 0
  E'Parents'Num1 -> 1

-- | parse 'E'Parents' enum
toE'Parents :: Int -> P.Either String E'Parents
toE'Parents = \case
  0 -> P.Right E'Parents'Num0
  1 -> P.Right E'Parents'Num1
  s -> P.Left $ "toE'Parents: enum parse failure: " P.++ P.show s



