<?php
/**
 * Category
 *
 * PHP version 5
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Keepa API
 *
 * The Keepa API offers numerous endpoints.  Every request requires your API access key as a parameter. You can find and change your key in the keepa portal. All requests must be issued as a HTTPS GET and accept gzip encoding. If possible, use a Keep-Alive connection.  Multiple requests can be made in parallel to increase throughput.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: info@keepa.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.0.0-beta2
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * Category Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class Category implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'category';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'domain_id' => 'int',
        'cat_id' => 'int',
        'name' => 'string',
        'children' => 'int[]',
        'parent' => 'int',
        'highest_rank' => 'int',
        'product_count' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPIFormats = [
        'domain_id' => 'int32',
        'cat_id' => 'int32',
        'name' => null,
        'children' => 'int32',
        'parent' => 'int32',
        'highest_rank' => 'int32',
        'product_count' => 'int32'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'domain_id' => 'domainId',
        'cat_id' => 'catId',
        'name' => 'name',
        'children' => 'children',
        'parent' => 'parent',
        'highest_rank' => 'highestRank',
        'product_count' => 'productCount'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'domain_id' => 'setDomainId',
        'cat_id' => 'setCatId',
        'name' => 'setName',
        'children' => 'setChildren',
        'parent' => 'setParent',
        'highest_rank' => 'setHighestRank',
        'product_count' => 'setProductCount'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'domain_id' => 'getDomainId',
        'cat_id' => 'getCatId',
        'name' => 'getName',
        'children' => 'getChildren',
        'parent' => 'getParent',
        'highest_rank' => 'getHighestRank',
        'product_count' => 'getProductCount'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const DOMAIN_ID_1 = 1;
    const DOMAIN_ID_2 = 2;
    const DOMAIN_ID_3 = 3;
    const DOMAIN_ID_4 = 4;
    const DOMAIN_ID_5 = 5;
    const DOMAIN_ID_6 = 6;
    const DOMAIN_ID_7 = 7;
    const DOMAIN_ID_8 = 8;
    const DOMAIN_ID_9 = 9;
    const DOMAIN_ID_10 = 10;
    const DOMAIN_ID_11 = 11;
    const DOMAIN_ID_12 = 12;
    const DOMAIN_ID_13 = 13;
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDomainIdAllowableValues()
    {
        return [
            self::DOMAIN_ID_1,
            self::DOMAIN_ID_2,
            self::DOMAIN_ID_3,
            self::DOMAIN_ID_4,
            self::DOMAIN_ID_5,
            self::DOMAIN_ID_6,
            self::DOMAIN_ID_7,
            self::DOMAIN_ID_8,
            self::DOMAIN_ID_9,
            self::DOMAIN_ID_10,
            self::DOMAIN_ID_11,
            self::DOMAIN_ID_12,
            self::DOMAIN_ID_13,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['domain_id'] = isset($data['domain_id']) ? $data['domain_id'] : null;
        $this->container['cat_id'] = isset($data['cat_id']) ? $data['cat_id'] : null;
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['children'] = isset($data['children']) ? $data['children'] : null;
        $this->container['parent'] = isset($data['parent']) ? $data['parent'] : null;
        $this->container['highest_rank'] = isset($data['highest_rank']) ? $data['highest_rank'] : null;
        $this->container['product_count'] = isset($data['product_count']) ? $data['product_count'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['domain_id'] === null) {
            $invalidProperties[] = "'domain_id' can't be null";
        }
        $allowedValues = $this->getDomainIdAllowableValues();
        if (!is_null($this->container['domain_id']) && !in_array($this->container['domain_id'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'domain_id', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['cat_id'] === null) {
            $invalidProperties[] = "'cat_id' can't be null";
        }
        if ($this->container['name'] === null) {
            $invalidProperties[] = "'name' can't be null";
        }
        if ($this->container['children'] === null) {
            $invalidProperties[] = "'children' can't be null";
        }
        if ($this->container['parent'] === null) {
            $invalidProperties[] = "'parent' can't be null";
        }
        if ($this->container['highest_rank'] === null) {
            $invalidProperties[] = "'highest_rank' can't be null";
        }
        if ($this->container['product_count'] === null) {
            $invalidProperties[] = "'product_count' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets domain_id
     *
     * @return int
     */
    public function getDomainId()
    {
        return $this->container['domain_id'];
    }

    /**
     * Sets domain_id
     *
     * @param int $domain_id Integer value for the Amazon locale you want to access. (1-com, 2-co.uk, 3-de, 4-fr, 5-co.jp, 6-ca, 7-cn, 8-it, 9-es, 10-in, 11-com.mx, 12-com.br, 13-com.au)
     *
     * @return $this
     */
    public function setDomainId($domain_id)
    {
        $allowedValues = $this->getDomainIdAllowableValues();
        if (!in_array($domain_id, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'domain_id', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['domain_id'] = $domain_id;

        return $this;
    }

    /**
     * Gets cat_id
     *
     * @return int
     */
    public function getCatId()
    {
        return $this->container['cat_id'];
    }

    /**
     * Sets cat_id
     *
     * @param int $cat_id The category node id used by Amazon. Represents the identifier of the category. Also part of the Product object’s categories and rootCategory fields. Always a positive Long value. Note - The id 9223372036854775807 (max signed long value) denotes a blank category with the name “?”. We use this in cases where a product is listed in no or non-existent categories.
     *
     * @return $this
     */
    public function setCatId($cat_id)
    {
        $this->container['cat_id'] = $cat_id;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name The name of the category.
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets children
     *
     * @return int[]
     */
    public function getChildren()
    {
        return $this->container['children'];
    }

    /**
     * Sets children
     *
     * @param int[] $children List of all sub categories. null or [] (empty array) if the category has no sub categories.
     *
     * @return $this
     */
    public function setChildren($children)
    {
        $this->container['children'] = $children;

        return $this;
    }

    /**
     * Gets parent
     *
     * @return int
     */
    public function getParent()
    {
        return $this->container['parent'];
    }

    /**
     * Sets parent
     *
     * @param int $parent The parent category’s Id. Always a positive Long value. If it is 0 the category is a root category and has no parent category.
     *
     * @return $this
     */
    public function setParent($parent)
    {
        $this->container['parent'] = $parent;

        return $this;
    }

    /**
     * Gets highest_rank
     *
     * @return int
     */
    public function getHighestRank()
    {
        return $this->container['highest_rank'];
    }

    /**
     * Sets highest_rank
     *
     * @param int $highest_rank The highest (root category) sales rank we have observed of a product that is listed in this category. Note- Estimate, as the value is from the Keepa product database and not retrieved from Amazon.
     *
     * @return $this
     */
    public function setHighestRank($highest_rank)
    {
        $this->container['highest_rank'] = $highest_rank;

        return $this;
    }

    /**
     * Gets product_count
     *
     * @return int
     */
    public function getProductCount()
    {
        return $this->container['product_count'];
    }

    /**
     * Sets product_count
     *
     * @param int $product_count Number of products that are listed in this category. Note- Estimate, as the value is from the Keepa product database and not retrieved from Amazon.
     *
     * @return $this
     */
    public function setProductCount($product_count)
    {
        $this->container['product_count'] = $product_count;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }
}


