{-
   Keepa API
   The Keepa API offers numerous endpoints.  Every request requires your API access key as a parameter. You can find and change your key in the keepa portal. All requests must be issued as a HTTPS GET and accept gzip encoding. If possible, use a Keep-Alive connection.  Multiple requests can be made in parallel to increase throughput.

   OpenAPI spec version: 1.0.0
   Contact: info@keepa.com

   NOTE: This file is auto generated by the openapi-generator.
   https://github.com/openapitools/openapi-generator.git
   Do not edit this file manually.
-}


module Data.Category exposing (Category, DomainId(..), decoder, encode)

import Dict exposing (Dict)
import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline exposing (optional, required)
import Json.Encode as Encode


type alias Category =
    { domainId : DomainId
    , catId : Int
    , name : String
    , children : (List (Maybe Int))
    , parent : Int
    , highestRank : Int
    , productCount : Int
    }


type DomainId
    = N1
    | N2
    | N3
    | N4
    | N5
    | N6
    | N7
    | N8
    | N9
    | N10
    | N11
    | N12
    | N13



decoder : Decoder Category
decoder =
    Decode.succeed Category
        |> required "domainId" domainIdDecoder
        |> required "catId" Decode.int
        |> required "name" Decode.string
        |> required "children" (Decode.list (Decode.nullable Decode.int) Nothing)
        |> required "parent" Decode.int
        |> required "highestRank" Decode.int
        |> required "productCount" Decode.int



encode : Category -> Encode.Value
encode model =
    Encode.object
        [ ( "domainId", encodeDomainId model.domainId )
        , ( "catId", Encode.int model.catId )
        , ( "name", Encode.string model.name )
        , ( "children", (Encode.list Maybe.withDefault Encode.null (Maybe.map Encode.int)) model.children )
        , ( "parent", Encode.int model.parent )
        , ( "highestRank", Encode.int model.highestRank )
        , ( "productCount", Encode.int model.productCount )

        ]



domainIdDecoder : Decoder DomainId
domainIdDecoder =
    Decode.string
        |> Decode.andThen
            (\str ->
                case str of
                    "1" ->
                        Decode.succeed N1

                    "2" ->
                        Decode.succeed N2

                    "3" ->
                        Decode.succeed N3

                    "4" ->
                        Decode.succeed N4

                    "5" ->
                        Decode.succeed N5

                    "6" ->
                        Decode.succeed N6

                    "7" ->
                        Decode.succeed N7

                    "8" ->
                        Decode.succeed N8

                    "9" ->
                        Decode.succeed N9

                    "10" ->
                        Decode.succeed N10

                    "11" ->
                        Decode.succeed N11

                    "12" ->
                        Decode.succeed N12

                    "13" ->
                        Decode.succeed N13

                    other ->
                        Decode.fail <| "Unknown type: " ++ other
            )



encodeDomainId : DomainId -> Encode.Value
encodeDomainId model =
    case model of
        N1 ->
            Encode.string "1"

        N2 ->
            Encode.string "2"

        N3 ->
            Encode.string "3"

        N4 ->
            Encode.string "4"

        N5 ->
            Encode.string "5"

        N6 ->
            Encode.string "6"

        N7 ->
            Encode.string "7"

        N8 ->
            Encode.string "8"

        N9 ->
            Encode.string "9"

        N10 ->
            Encode.string "10"

        N11 ->
            Encode.string "11"

        N12 ->
            Encode.string "12"

        N13 ->
            Encode.string "13"



