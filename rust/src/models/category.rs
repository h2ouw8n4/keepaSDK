/* 
 * Keepa API
 *
 * The Keepa API offers numerous endpoints.  Every request requires your API access key as a parameter. You can find and change your key in the keepa portal. All requests must be issued as a HTTPS GET and accept gzip encoding. If possible, use a Keep-Alive connection.  Multiple requests can be made in parallel to increase throughput.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: info@keepa.com
 * Generated by: https://openapi-generator.tech
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct Category {
  /// Integer value for the Amazon locale you want to access. (1-com, 2-co.uk, 3-de, 4-fr, 5-co.jp, 6-ca, 7-cn, 8-it, 9-es, 10-in, 11-com.mx, 12-com.br, 13-com.au)
  #[serde(rename = "domainId")]
  domain_id: i32,
  /// The category node id used by Amazon. Represents the identifier of the category. Also part of the Product object’s categories and rootCategory fields. Always a positive Long value. Note - The id 9223372036854775807 (max signed long value) denotes a blank category with the name “?”. We use this in cases where a product is listed in no or non-existent categories.
  #[serde(rename = "catId")]
  cat_id: i32,
  /// The name of the category.
  #[serde(rename = "name")]
  name: String,
  /// List of all sub categories. null or [] (empty array) if the category has no sub categories.
  #[serde(rename = "children")]
  children: Vec<i32>,
  /// The parent category’s Id. Always a positive Long value. If it is 0 the category is a root category and has no parent category.
  #[serde(rename = "parent")]
  parent: i32,
  /// The highest (root category) sales rank we have observed of a product that is listed in this category. Note- Estimate, as the value is from the Keepa product database and not retrieved from Amazon.
  #[serde(rename = "highestRank")]
  highest_rank: i32,
  /// Number of products that are listed in this category. Note- Estimate, as the value is from the Keepa product database and not retrieved from Amazon.
  #[serde(rename = "productCount")]
  product_count: i32
}

impl Category {
  pub fn new(domain_id: i32, cat_id: i32, name: String, children: Vec<i32>, parent: i32, highest_rank: i32, product_count: i32) -> Category {
    Category {
      domain_id: domain_id,
      cat_id: cat_id,
      name: name,
      children: children,
      parent: parent,
      highest_rank: highest_rank,
      product_count: product_count
    }
  }

  pub fn set_domain_id(&mut self, domain_id: i32) {
    self.domain_id = domain_id;
  }

  pub fn with_domain_id(mut self, domain_id: i32) -> Category {
    self.domain_id = domain_id;
    self
  }

  pub fn domain_id(&self) -> &i32 {
    &self.domain_id
  }


  pub fn set_cat_id(&mut self, cat_id: i32) {
    self.cat_id = cat_id;
  }

  pub fn with_cat_id(mut self, cat_id: i32) -> Category {
    self.cat_id = cat_id;
    self
  }

  pub fn cat_id(&self) -> &i32 {
    &self.cat_id
  }


  pub fn set_name(&mut self, name: String) {
    self.name = name;
  }

  pub fn with_name(mut self, name: String) -> Category {
    self.name = name;
    self
  }

  pub fn name(&self) -> &String {
    &self.name
  }


  pub fn set_children(&mut self, children: Vec<i32>) {
    self.children = children;
  }

  pub fn with_children(mut self, children: Vec<i32>) -> Category {
    self.children = children;
    self
  }

  pub fn children(&self) -> &Vec<i32> {
    &self.children
  }


  pub fn set_parent(&mut self, parent: i32) {
    self.parent = parent;
  }

  pub fn with_parent(mut self, parent: i32) -> Category {
    self.parent = parent;
    self
  }

  pub fn parent(&self) -> &i32 {
    &self.parent
  }


  pub fn set_highest_rank(&mut self, highest_rank: i32) {
    self.highest_rank = highest_rank;
  }

  pub fn with_highest_rank(mut self, highest_rank: i32) -> Category {
    self.highest_rank = highest_rank;
    self
  }

  pub fn highest_rank(&self) -> &i32 {
    &self.highest_rank
  }


  pub fn set_product_count(&mut self, product_count: i32) {
    self.product_count = product_count;
  }

  pub fn with_product_count(mut self, product_count: i32) -> Category {
    self.product_count = product_count;
    self
  }

  pub fn product_count(&self) -> &i32 {
    &self.product_count
  }


}



